#!/usr/bin/ruby

def usage()
  puts <<-EOF
    usage: ruby kmod_gemerator.rb device_name

    device_name is a device name you want to generate in /dev directory.
  EOF
end

if ARGV.size != 1
  usage()
  exit 1
end

devname = ARGV.shift

kmod_src=<<-EOF
/**
 * This file is generated by kmod_generator.rb. 
 * Written by Yourname.
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/ioctl.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/jiffies.h>
#include <linux/kdev_t.h>
#include <asm/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name.");
MODULE_DESCRIPTION("Change Here.");


static int #{devname}_devs = 1;
static int #{devname}_major = 0;
static int #{devname}_minor = 0;
static struct cdev #{devname}_cdev;
static struct class *#{devname}_class=NULL;
static dev_t #{devname}_dev;

#define IOC_MAGIC 'd'

#define #{devname.upcase}_TEST_PRINTK _IOR(IOC_MAGIC, 1, unsigned int)


int #{devname}_ioctl(struct inode *inode, struct file *filp, unsigned int e,unsigned long arg)
{
	int ret;

	//printk("ioctl.\\n");

	switch(e){
		case #{devname.upcase}_TEST_PRINTK:
		{
			printk("#{devname}:test\\n");
			ret = 0;
		}
		default:
		{
			ret = -1;
		}
	}
	
	return ret;
}


ssize_t #{devname}_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	return 0;	
}

int #{devname}_open(struct inode *inode, struct file *filp)
{
	return 0;	
}

int #{devname}_close(struct inode *inode, struct file *filp)
{
	return 0;
}

static struct file_operations #{devname}_fops = {
#if 1
	.owner = THIS_MODULE,
	.open = #{devname}_open,
	.release = #{devname}_close,
	.read = #{devname}_read,
	.ioctl = #{devname}_ioctl,
#else
	.unlocked_ioctl = #{devname}_ioctl
#endif
};

static int #{devname}_init(void)
{
	// dev_t は ビットで表現.
	// これをうまくとりはからうのがMKDEV.
	dev_t dev = MKDEV(#{devname}_major,0);
	int r = 0;
	int major = 0;
	int cdev_err = 0;
	struct class_device *class_dev=NULL;

	//printk("0.\\n");
	r = alloc_chrdev_region( &dev, 0, #{devname}_devs, "#{devname}");
	if ( r )
		goto error;	
	#{devname}_major = major = MAJOR(dev);
	
	cdev_init(&#{devname}_cdev, &#{devname}_fops);
	//printk("2.\\n");
	#{devname}_cdev.owner = THIS_MODULE;
	#{devname}_cdev.ops = &#{devname}_fops;

	cdev_err = cdev_add(&#{devname}_cdev, MKDEV(#{devname}_major, #{devname}_minor), 1);
	//printk("3.\\n");
	if ( cdev_err )
		goto error;

	#{devname}_class = #{devname}_class = class_create(THIS_MODULE,"#{devname}");
	if ( IS_ERR(#{devname}_class) ){
		goto error;
	}

	#{devname}_dev = MKDEV(#{devname}_major, #{devname}_minor);
	class_dev = device_create(
					#{devname}_class,
					NULL,
					#{devname}_dev,
					NULL,
					"#{devname}",
					#{devname}_minor);	

	printk("#{devname} driver loaded.\\n");
	
	return 0;

error:
	if ( cdev_err == 0 )
		cdev_del(&#{devname}_cdev);
	if ( r == 0 )
		unregister_chrdev_region( dev, #{devname}_devs);
	
	return 1;
}

static void #{devname}_exit(void)
{
	dev_t dev = MKDEV( #{devname}_major , 0);
	device_destroy(#{devname}_class, #{devname}_dev);
	class_destroy(#{devname}_class);

	cdev_del(&#{devname}_cdev);
	unregister_chrdev_region(dev, #{devname}_devs);
	printk("#{devname} driver removed.\\n");
}

module_init(#{devname}_init);
module_exit(#{devname}_exit);
EOF

makefile_src=<<-EOF
KERNELSRCDIR = /lib/modules/`uname -r`/build
BUILD_DIR := $(shell pwd)
VERBOSE = 0

# モジュール名
obj-m := #{devname}.o
#shortcut_guest.o

# <モジュール名>-objs にモジュールを構成するオブジェクトの一覧を列挙する
tko-objs := #{devname}.o

all:
	make -C $(KERNELSRCDIR) SUBDIRS=$(BUILD_DIR) KBUILD_VERBOSE=$(VERBOSE) modules 

test:
	gcc test.c -o test

clean:
	rm -f *.o
	rm -f *.ko
	rm -f *.mod.c
	rm -f *~
	rm -f modules.order
	rm -f Module.symvers

i:
	sudo insmod ./#{devname}.ko
	cat /proc/devices | grep #{devname}
r:
	sudo rmmod #{devname}
EOF

puts devname+".c"
puts kmod_src
puts "Makefile"
puts makefile_src

open(devname+".c","w+") { |f| f.puts(kmod_src) }
open("Makefile","w+") { |f|  f.puts(makefile_src) }
